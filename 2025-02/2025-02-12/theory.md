# :books: 도커 개념 보충 및 실습

# 도커 볼륨

일반적으로 컨테이너 내부에서 생성한 데이터는 컨테이너가 종료되거나 삭제되면 사라진다. 그러나 도커 볼륨은 컨테이너의 데이터를 영구적으로 저장하기 위해 사용하는 Docker에서 관리하는 저장 공간으로 볼륨을 사용하면 컨테이너가 삭제되어도 데이터가 유지된다.

## 도커 볼륨 사용 이유

1. 데이터 영속성
    - 컨테이너가 삭제되면 컨테이너 내부의 파일도 사라지지만, 볼륨을 사용하면 컨테이너 삭제 후에도 데이터가 유지된다.
    - ex) 데이터베이스 컨테이너(MySQL, PostgreSQL)에서 데이터를 유지하려면 볼륨을 사용해야 한다.
2. 여러 컨테이너 간 데이터 공유
    - 여러 개의 컨테이너가 같은 볼륨을 공유할 수 있다.
3. 호스트와의 독립성 유지
    - 바인드 마운트와 달리, 볼륨은 호스트 OS의 특정 경로에 의존하지 않아서 더 이식성이 높다.
    - 즉, 컨테이너가 실행되는 운영체제나 경로가 달라도 동일하게 동작한다.
4. 보안 & 성능 최적화
    - 볼륨은 Docker가 직접 관리하는 저장소이기 때문에, 파일 시스템 성능 최적화 및 권한 관리가 더 효과적으로 이루어진다.

## 익명 볼륨

별도의 이름이나 식별자 없이 도커 엔진에 의해 자동으로 생성되는 볼륨. 컨테이너를 실행할 때 옵션을 사용하여 호스트 경로를 지정하지 않으면 익명 볼륨이 자동으로 생성된다.

- 임시적인 데이터나 일시적인 파일 시스템에 사용될 때 유용하고, 컨테이너가 삭제되면 익명 볼륨에 저장된 데이터도 함께 삭제된다.

```docker
docker run -v [컨테이너 내부 경로] [이미지 이름]
```

## 명명 볼륨

볼륨에 고유한 이름을 지정하여 생성하는 볼륨이다. 호스트 경로 대신 {볼륨이름:컨테이너경로}형식으로 지정한다.

- 컨테이너를 삭제해도 명명된 볼륨은 삭제되지 않으므로 데이터를 보존할 수 있다.

```docker
docker run -v [볼륨 이름]:[컨테이너 내부 경로] [이미지 이름]
```

## 바인드 마운트

호스트 머신의 파일이나 디렉토리를 컨테이너 내부에 직접 마운트하는 방식이다. 내부와 외부의 디렉토리가 연결되어 있기 때문에, 호스트 머신 쪽에서 코드를 수정할 일이 생겨서, 수정하게 되면 내부 컨테이너에도 똑같이 반영 되는데, 이러한 방식은 개발 환경에서 소스 코드나 설정 파일을 실시간으로 변경하고 테스트할 때 유용하게 사용될 것!

```docker
docker run -v [호스트 경로]:[컨테이너 내부 경로] [이미지 이름]
```

# IaC (Infra as Code)

IaC는 인프라를 코드로 정의하고 관리하는 방식이다. 이는 서버, 네트워크, 데이터베이스, 로드 밸런서 등과 같은 인프라를 사람이 수동으로 설정하는 것이 아니라, 코드와 설정 파일을 사용하여 자동화하는 것을 의미.

## IaC가 필요한 이유

전통적인 인프라 관리 방식은 사람이 직접 서버를 구성하고 설정하는 수동 프로세스였다. 하지만 클라우드 환경이 발전하면서 인프라의 규모가 커지고 복잡성이 증가하면서 자동화의 필요성이 커졌다.

- 일관성 유지: 코드 기반이므로 모든 환경에서 동일한 인프라를 재현할 수 있음
- 자동화 및 속도: 클릭 몇 번 또는 명령어 실행만으로 인프라 배포 가능
- 변경 이력 관리: Git과 같은 VCS로 변경사항을 추적하고 롤백 가능
- 확장성: 클라우드 환경에서 여러 개의 인프라를 쉽게 확장할 수 있음
- 비용 절감: 인프라 프로비저닝을 자동화하여 운영 비용 절감

## Dockerfile

컨테이너 빌드에 필요한 작업 명령이 저장된 파일을 뜻한다. 도커 엔진은 현재 디렉토리의 “Dockerfile”이라는 이름의 파일을 인식하여 image 생성한다.

- `docker build .`: Dockerfile을 이용한 이미지 생성 명령
    - `-t`: 생성할 이미지 이름 정의 옵션
- 한줄이 하나의 명령어
    - FROM: 베이스가 될 이미지 정의
    - LABEL: 이미지에 메타데이터 추가, “키:값” 형태로 정의
    - RUN: 이미지를 만들기 위해 컨테이너 내부에서 명령어 실행
        - ex) `RUN ["sh", "-c", "echo $MY_ENV"]`
    - ADD: Dockerfile이 위치한 디렉토리의 파일 이미지에 추가
    - WORKDIR: 명령어를 실행할 디렉토리 정의, cd 명령과 같은 기능
    - EXPOSE: 생성한 이미지에서 노출할 포트 정의
    - CMD: 컨테이너가 시작될 때 실행되는 명령 설정

### 실습

```html
test
```

```docker
FROM ubuntu:14.04

LABEL "purpose"="practice"

RUN apt-get update

RUN apt-get install apache2 -y

ADD test.html /var/www/html

WORKDIR /var/www/html

RUN [ "/bin/bash", "-c", "echo hello >> test2.html" ]

EXPOSE 80

CMD apachectl -DFOREGROUND
```

CMD를 셸 형식으로 작성하니 오류가 발생했다…

![image.png](/images/2025-02/2025-02-12/1.png)

찾아 보니, 셸 형식은 Docker 컨테이너 내부에서 Bash(또는 sh)를 통해 실행되므로, 신호 처리 문제가 발생할 수 있다고 한다. 따라서 JSON 배열 형식으로 변경!

```docker
FROM ubuntu:14.04

LABEL "purpose"="practice"

RUN apt-get update

RUN apt-get install apache2 -y

ADD test.html /var/www/html

WORKDIR /var/www/html

RUN [ "/bin/bash", "-c", "echo hello >> test2.html" ]

EXPOSE 80

CMD [ "apachectl", "-DFOREGROUND" ]
```

이후 컨테이너를 실행하고, 포트를 확인했다.

![image.png](/images/2025-02/2025-02-12/2.png)

![image.png](/images/2025-02/2025-02-12/3.png)

![image.png](/images/2025-02/2025-02-12/4.png)