# :books: 도커

# 도커

- 리눅스 컨테이너에 여러 기능을 추가
- 애플리케이션을 컨테이너로 좀 더 쉽게 사용할 수 있게 만든 오픈소스 프로젝트
- 2013년 3월 dotCloud 창업자 Solomon Hykes가 Pycon Conference에서 발표
- Go 언어로 작성됨
- 가상 먼신과 달리 성능손실이 거의 없는 차세대 클라우드 솔루션으로 주목

![image.png](/images/2025-02/2025-02-11/1.png)

## 가상 머신과 도커 컨테이너

### 가상 머신

- 하이퍼바이저를 통한 가상화로 성능 손실이 발생
- 완벽한 독립적 공간을 생성 하나, 이미지 용량이 크고 가상머신 배포에 부담

### 도커 컨테이너

- 리눅스 Chroot, 네임스페이스, Cgroup를 사용한 프로세스 단위 격리 환경 구성
- 애플리케이션 구동을 위한 라이브러리만 포함한 이미지생성, 용량이 작음
- 서비스 컨테이너화
    - 컨테이너에 하나의 애플리케이션만 실행
    - 컨테이너간 독립성 보장으로 버전관리 및 소스 모듈화 등이 쉬움
    - 한 컨테이너에 프로세스 하나만 실행 → 도커 철학

## 컨테이너 기술의 장점

- 하이버바이저와 게스트 OS가 없기 때문에, 경량화되었다.
- 경량이기 때문에, 이미지 복제, 이관, 배포가 쉽고 효율적이다.
- 게스트 OS를 부팅하지 않기 때문에, container 수행 시간이 빠르다
- 한정된 하드웨어 자원 안에서 vm보다 더 많은 container를 실행할 수 있어서 효율적이다.

## 도커 이미지와 컨테이너

### 도커 이미지

- 가상머신 생성 시 사용하는 ISO와 비슷한 개념의 이미지
- 여러 개의 층으로 된 바이너리 파일로 존재
- 컨테이너 생성 시 읽기 전용으로 사용됨
- 도커 명령어로 레지스트리로부터 다운로드 가능
    
    ![image.png](/images/2025-02/2025-02-11/2.png)
    
    - 저장소 이름: 이미지가 저장된 장소, 이름이 없으면 도커 허브로 인식
    - 이미지 이름: 이미지의 역할을 나타낼 이름, 생략 불가능
    - 이미지 버전: 이미지 버전정보, 생략하면 latest로 인식

### 도커 컨테이너

- 도커 이미지로부터 생성됨
- 격리된 파일시스템, 시스템 자원, 네트워크를 사용할 수 있는 독립공간 생성
- 도커 이미지 목적에 맞게 컨테이너를 생성하는 것이 일반적
    - 예) 웹 서버 도커 이미지로부터 여러 개의 컨테이너 생성 = 개수만큼의 웹서버
- 이미지를 읽기 전용으로 사용, 이미지 변경 데이터는 컨테이너 계층에 저장
- 컨테이너의 애플리케이션 설치/삭제는 다른 컨테이너에 영향이 없음
    - 예) 우분투 이미지로 별도의 컨테이너 생성 후 Apache, Mysql 설치/삭제 가능

# 도커 다루기

### 도커 파일 빌드

```docker
#docker build .
```

Dockerfile을 빌드하고 이 파일을 바탕으로 이미지를 생성한다.

- `-t NAME:TAG`: 이미지의 이름과 태그를 할당할 수 있게하는 옵션

### 도커 엔진 버전 확인

```docker
#docker -v
Docker version 20.10.18. build 100c701
```

### 컨테이너 생성 후 실행

```docker
#docker run -it ubuntu
```

- run: 컨테이너를 생성하고 실행
    - -i (—interactive): 컨테이너의 표준입력(STDIN)을 유지해서 사용자가 입력할 수 있도록 하는 옵션. 기본적으로 컨테이너는 백그라운드에서 실행되면 입력을 받을 수 없지만, -i를 사용해 사용자의 입력을 받을 수 있음.
    - -t (—tty): 가상 터미널(TTY)을 생성해서 터미널환경을 제공하는 옵션. 터미널을 애뮬레이션해서 색상, 커서 이동, 줄바꿈 같은 기능을 제공할 수 있음
    - 정리하면 다음과 같다.
    
    | 옵션 | 역할 | 언제 사용? |
    | --- | --- | --- |
    | -i | 표준 입력을 유지하여 사용자의 입력을 받을 수 있도록 함 | 프로그램이 사용자 입력을 필요로 할 때 (cat, python, mysql 등) |
    | -t | 터미널을 제공하여 색상 출력, 명령어 편집 등을 지원 | 셸 환경을 실행할 때 (bash, ls —color, vim 등) |
    | -it | 입력 가능 + 터미널 환경 제공 | 컨테이너 내부에서 직접 명령어를 실행해야 할 때 (bash, sh, python 등) |
    - `--name NAME`: 컨테이너에 이름을 할당한다. 이 이름은 지우거나 그 컨테이너를 멈추는 데에 사용된다.
    - `-d`: 컨테이너를 detached 모드로 실행한다. Detached 모드는 컨테이너를 백그라운드에서 실행하는 모드로 이 옵션을 킨 상태로 실행하면 즉시 터미널을 반환하며, 백그라운드에서 실행 상태를 유지한다.
    - `--rm`: 컨테이너가 멈추면 자동으로 컨테이너를 삭제하는 옵션.
    - `-p`: 호스트 포트와 컨테이너 포트를 연결하는 옵션.

### 컨테이너 및 이미지 리스트

```docker
#docker ps

#docker images
```

- `docker ps`: 실행 중인 모든 컨테이너를 출력한다.
    - `-a`: 실행 중이지 않은 컨테이너까지 출력한다. 즉, 모든 컨테이너를 출력한다.
- `docker images`: 로컬에 저장되어 있는 이미지들을 출력한다.

### 컨테이너 및 이미지 삭제

```docker
#docker rm CONTAINER

#docker rmi IMAGE

#docker container prune

#docker image prune
```

- `docker rm CONTAINER`: 컨테이너의 아이디 및 이름을 통해 컨테이너를 삭제하는 명령어.
- `docker rmi IMAGE`: 이미지의 이름이나 아이디를 통해 이미지를 삭제하는 명령어.
- `docker container prune`: 중지되어 있는 모든 컨테이너를 삭제한다.
- `docker image prune`: 태그가 되어 있지 않는 모든 이미지들을 삭제한다.
    - `-a`: 로컬에 저장되어 있는 모든 이미지들을 삭제한다.

### 이미지 푸시와 풀

```docker
#docker push IMAGE

#docker pull IMAGE
```

- `docker push IMAGE`: DockerHub에 이미지를 푸시한다. 이미지의 이름과 태그, 레포지토리의 주소의 이름이 포함되어 있어야 한다.
- `docker pull IMAGE`: DockerHub에서 이미지를 풀한다. 이 작업은 만약 `docker run IMAGE`를 했는데, 이전에 그 이미지를 풀한 내역이 없으면 자동으로 실행한다.

# 도커 이미지

Application을 포장 및 전송하기 위해 도커는 이미지를 사용한다. Docker Image는 파일로 애플리케이션 실행에 필요한 독립적인 환경을 포함하며, 런타임 환경을 위한 일종의 템플릿이다.

도커 이미지는 소스 코드, 라이브러리, 종속성 도구 및 응용 프로그램을 실행하는데 필요한 기타 파일을 포함하는 불변 파일이다. 이렇게 이미지는 읽기 전용이므로 스냅샷이라고도 하며, 특정 시점의 애플리케이션과 가상 환경을 나타낸다.

→ 이런 일관성을 통해 개발자가 안정적이고 균일한 조건에서 소프트웨어를 테스트하고 실험할 수 있도록 한다.

![image.png](/images/2025-02/2025-02-11/3.png)

컨테이너를 생성하는 이미지 베이스는 별도로 존재하며 변경할 수 없다. 컨테이너 환경을 실행할 때는 기본적으로 컨테이너 내부에 해당 파일 시스템(도커 이미지)의 읽기-쓰기 복사본을 만든다. 이렇게 하면 이미지 전체 복사본을 수정할 수 있는 컨테이너 레이어가 추가된다.

하나의 베이스 이미지에서 도커 이미지를 무제한으로 생성할 수 있고, 이미지의 초기 상태를 변경하고 기존 상태를 저장할 때마다 추가 레이어가 있는 새 템플릿을 만든다. 따라서 도커 이미지는 여러 개의 레이어로 구성될 수 있으며, 각각은 다르지만 이전 레이어에서 비롯된다. 이미지 계층은 컨테이너 계층을 사용하여 가상 환경을 시작할 때 추가된 읽기 전용 파일을 나타낸다.

일반적으로 다음과 같은 순서로 컨테이너를 제작한다.

<aside>
💡

Dockerfile —(Build)—> Image —(Create)—> Container

</aside>

- Dockerfile은 도커 이미지를 빌드하는 방법을 정의하는 스크립트이다.
- 이 Dockerfile을 빌드해서 이미지를 생성한다.
- Image는 특정 환경에 대한 정보가 변하지 않고 저장되는 정적인 형태의 파일이다.
- 이미지를 동적인 형태로 변경한 것이 컨테이너이며, 컨테이너가 구동된다는 것은 우리가 필요로 하는 OS와 특정 환경이 경량 가상화로 구현된다는 것을 의미한다.

## 도커 이미지 생성 방법 1

현재 구동 중인 Container에 있는 것을 그대로 image로 만드는 방법이 있다. 이 방법은 다음과 같은 순서로 진행된다.

1. 기본 OS 이미지로 컨테이너 생성
2. 애플리케이션 설치 및 환경설정, 소스코드 복제
3. 컨테이너 이미지 커밋(commit)
    
    ![image.png](/images/2025-02/2025-02-11/4.png)
    

이 방법은 애플리케이션 설치, 환경 구성 변경 등을 직접 수작업하고 애플리케이션 구동 이미지로 커밋하기 때문에, 이미지 동작을 보장해주는 특징이 있다.

## 도커 이미지 생성 방법 2

Dockerfile로 이미지를 생성하는 방법이다. 이 방법은 다음과 같은 순서로 진행된다.

1. 매뉴얼 작업을 기록한 Dockerfile 생성
2. 빌드 명령어가 Dockerfile을 읽어 이미지를 생성

![image.png](/images/2025-02/2025-02-11/5.png)

- 이미지를 직접 생성 또는 커밋하지 않아도 됨.
- 애플리케이션 빌드를 자동화
- 도커 허브의 신뢰할 수 있는 이미지를 바탕으로 쉽게 이미지 배포 가능
- Text 파일을 배포하므로, 경량화

## 실습

실습의 시나리오는 다음과 같다.

1. Docker hub에서 nginx image를 불러와서, container로 동작
2. Nginx의 기본 index.html을 수정한다.
3. 저장하여 새로운 commit_test:1.0 image를 만든다.
4. commit_test:1.0 image로 새로운 container를 띄운다.
5. 새로운 index.html을 host에서 cp한다.
6. 해당 container를 그대로 image화 시킨다. → commit_test:2.0

성공적으로 했다!

# 도커 이미지 배포 방법

도커의 이미지를 배포하는 방법에는 다음과 같은 3가지 방법이 있다.

1. 파일 배포: 도커 이미지를 파일로 내보내고 이를 다른 환경으로 복사하여 배포하는 방식. 인터넷 연결 없이도 배포가 가능하기 때문에 폐쇄망 환경이나 로컬 개발 환경에서 주로 사용된다.
2. Public Registry: Docker Hub 같은 공개 저장소를 사용하여 이미지를 배포하는 방식.
3. Private Registry: 자체적으로 도커 이미지를 관리할 프라이빗 레지스트리를 구축하여 이미지를 저장하고 배포하는 방식.

## 파일 배포

사용 방법은 대략적으로 다음과 같다.

1. 이미지 저장 (Export/Save)
    - docker save 명령어를 사용하여 도커 이미지를 `.tar` 파일로 저장한다.
        
        ```docker
        #docker save -o my_image.tar my_image:latest
        ```
        
    - docker export를 사용하면 컨테이너의 파일 시스템을 내보낼 수도 있다.
2. 파일을 전송
    - scp, rsync, USB. FTP 등으로 파일을 다른 시스템에 복사한다.
3. 이미지 불러오기 (Load/Import)
    - 새로운 환경에서 docker load로 이미지를 불러온다.
        
        ```docker
        #docker load -i my_image.tar
        ```
        
    - docker import를 사용하여 컨테이너 파일 시스템을 불러올 수도 있다.

> Load vs Import
Load: image에 container 정보들이 들어있음. Image의 Layer가 그대로 있다는 뜻
Import: Image에 container 정보가 없음. 즉, image의 기존 layer가 없고, 새로운 layer로 존재해 command 등을 다시 설정해주어야 container가 정상 동작함.
> 

### 실습

1. Docker 이미지를 .tar 파일로 저장하기 (docker save)
    
    ```docker
    docker pull nginx:latest
    
    docker save -o nginx_image.tar nginx:latest
    ```
    
    - `-o nginx_image.tar` → `nginx_image.tar` 파일로 저장
    - `nginx:latest` → 저장할 이미지 이름
    
    ![이미지 파일 생성 확인](/images/2025-02/2025-02-11/6.png)
    
    이미지 파일 생성 확인
    
2. 파일을 다른 환경으로 전송하기
    
    이 과정은 성공적으로 됐다고 생각하고 생략하기!
    
3. 이미지 불러오기
    
    ```docker
    docker load -i nginx_image.tar
    ```
    
    ![이미지 생성 확인](/images/2025-02/2025-02-11/7.png)
    
    이미지 생성 확인
    

## Public Registry 실습

사용 방법은 대략적으로 다음과 같다.

1. 이미지를 태깅
2. Docker Hub 로그인
3. 이미지 푸시
    
    Docker Hub에 nodeJs를 이미지화해서 푸시해놓았다.
    
    ![image.png](/images/2025-02/2025-02-11/8.png)
    
4. 다른 서버에서 이미지 다운로드
    
    이제 다시 이 이미지를 가져와 실행해보자.(pull)
    
    ```docker
    docker pull seriousbug98/node-hello-world:tagname
    ```
    
    ![성공적으로 pull](/images/2025-02/2025-02-11/9.png)
    
    성공적으로 pull
    

## Private Registry

사내 네트워크 또는 클라우드 환경에서 내부적으로 Docker 이미지를 관리하는 방법이다. 퍼블릭 레지스트리와 달리 보안성, 속도, 비용 절감 면에서 유리하다는 특징이 있다.

### 실습

실습은 다음과 같은 단계를 거쳐서 진행된다.

1. 프라이빗 레지스트리 구축 (registry 컨테이너 사용)
    
    Docker는 공식적으로 registry라는 컨테이너 이미지를 제공한다. 따라서 이를 사용하면 손쉽게 프라이빗 레지스트리를 구축할 수 있다.
    
    ```docker
    docker run -d -p 9000:5000 --name my_registry registry:2
    ```
    
    - `-d`: 백그라운드 실행
    - `-p`: 호스트의 9000번 포트를 컨테이너의 5000번 포트에 매핑
    - `registry:2`: 공식 Docker Registry 이미지 사용 (버전 2)
    
    ![Private Registry 실행](/images/2025-02/2025-02-11/10.png)
    
    Private Registry 실행
    
2. 도커 이미지를 프라이빗 레지스트리에 업로드 (docker push)
    
    Docker는 푸시할 때 태그를 기준으로 레지스트리를 인식한다. 따라서, 푸시 전에 태깅을 통해 프라이빗 레지스트리 주소를 명시해야 한다.
    
    ```docker
    docker pull nginx:latest
    docker tag nginx:latest localhost:9000/my-nginx
    docker push localhost:9000/my-nginx
    ```
    
    - `nginx:latest` → 기존 로컬 이미지
    - `localhost:9000/my-nginx` → 프라이빗 레지스트리에 맞는 태그로 변경
        - `localhost:9000` → 프라이빗 레지스트리 주소 (여기서는 localhost, 실제 환경에서는 서버 IP)
        - `my-nginx` → 저장될 이미지 이름
    - 푸시되는 과정
        1. Docker 클라이언트가 프라이빗 레지스트리(9000번 포트)로 연결 시도
        2. my-nginx의 레이어를 분석 후, 새로운 레이어만 업로드
        3. 푸시가 완료되면 레지스트리에 저장
    
    ![image.png](/images/2025-02/2025-02-11/11.png)
    
    ![image.png](/images/2025-02/2025-02-11/12.png)
    
    푸시된 이미지는 Docker Registry 서버의 `/var/lib/registry` 경로에 저장된다. 레지스트리 컨테이너 내부에 들어가 확인해보자.
    
    ```docker
    docker exec -it my_registry sh
    ls /var/lib/registry/docker/registry/v2/repositories/
    ```
    
    ![image.png](/images/2025-02/2025-02-11/13.png)
    
3. 다른 서버에서 프라이빗 레지스트리의 이미지를 다운로드 (docker pull)
    
    → 생략